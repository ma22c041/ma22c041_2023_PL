# -*- coding: utf-8 -*-
"""bisection method.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Guo4N0F_bf-lWppZfP6ebJ7Hrg66hJ7S
"""

def bisection(f, a, b, eps, niters): #definition a bisection
    if f(a) * f(b) >= 0:
        raise ValueError("Function values at interval endpoints must have different signs.")

    n = 0 #Initializes a variable n to 0
    while n < niters:
        m = (a + b) / 2  # to Calculate the midpoint m of the interval using (a + b) / 2
        if abs(f(m)) < eps:# to check f(m) is less then eps
            return m
        elif f(a) * f(m) < 0:
            b = m # to check fun values at a & m have different sign. if it is root lies b/w a & m so update to b=m
        else:
            a = m  #if above is not crt root lirs b/w b & m so uopdate to a=m
        n += 1 # increasing the iteration by 1

        if 2**(-n) * (b - a) <= eps: #to check present interval less than eps
            return m #statement stops the function and returns this value.

    return m

# Define the function for which we want to find the root
def f(x):
    return x - 1 - math.cos(x)

#  to Set the interval [a, b], error tolerance epsilon, and maximal number of iterations niters
a = 0
b = 2
epsilon = 1e-6
niters = 100

import math
root = bisection(f, a, b, epsilon, niters)
print("Approximate root:", root) # to print approximate root
print("f(root) =", f(root))